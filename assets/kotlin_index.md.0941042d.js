import{_ as s,c as a,o as n,a as l}from"./app.368cfe21.js";const D=JSON.parse('{"title":"Kotlin","description":"","frontmatter":{},"headers":[{"level":2,"title":"basic","slug":"basic","link":"#basic","children":[{"level":3,"title":"程序入口点","slug":"程序入口点","link":"#程序入口点","children":[]},{"level":3,"title":"类型","slug":"类型","link":"#类型","children":[]},{"level":3,"title":"流程控制","slug":"流程控制","link":"#流程控制","children":[]},{"level":3,"title":"包与导入","slug":"包与导入","link":"#包与导入","children":[]},{"level":3,"title":"类与对象","slug":"类与对象","link":"#类与对象","children":[]},{"level":3,"title":"函数","slug":"函数","link":"#函数","children":[]},{"level":3,"title":"Spring","slug":"spring","link":"#spring","children":[]}]}],"relativePath":"kotlin/index.md","lastUpdated":1674468953000}'),e={name:"kotlin/index.md"},o=l(`<h1 id="kotlin" tabindex="-1">Kotlin <a class="header-anchor" href="#kotlin" aria-hidden="true">#</a></h1><h2 id="basic" tabindex="-1">basic <a class="header-anchor" href="#basic" aria-hidden="true">#</a></h2><h3 id="程序入口点" tabindex="-1">程序入口点 <a class="header-anchor" href="#程序入口点" aria-hidden="true">#</a></h3><p>Kotlin 应用程序的入口点是 <code>main</code> 函数</p><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#FF7B72;">fun</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">main</span><span style="color:#C9D1D9;">() {</span></span>
<span class="line"><span style="color:#C9D1D9;">  </span><span style="color:#79C0FF;">println</span><span style="color:#C9D1D9;">(</span><span style="color:#A5D6FF;">&quot;Hello world!&quot;</span><span style="color:#C9D1D9;">)</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>main</code> 的另一种形式接收可变数量的 <code>String</code> 参数</p><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#FF7B72;">fun</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">main</span><span style="color:#C9D1D9;">(args</span><span style="color:#FF7B72;">:</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">Array</span><span style="color:#FF7B72;">&lt;</span><span style="color:#79C0FF;">String</span><span style="color:#FF7B72;">&gt;</span><span style="color:#C9D1D9;">) {</span></span>
<span class="line"><span style="color:#C9D1D9;">  </span><span style="color:#79C0FF;">println</span><span style="color:#C9D1D9;">(args.contentToString())</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="类型" tabindex="-1">类型 <a class="header-anchor" href="#类型" aria-hidden="true">#</a></h3><h4 id="基本类型" tabindex="-1">基本类型 <a class="header-anchor" href="#基本类型" aria-hidden="true">#</a></h4><blockquote><p>在 Kotlin 中，所有东西都是对象，在这个意义上讲可以在任何变量上调用成员函数与属性。一些类型可以有特殊的内部表示——例如，数字、字符以及布尔可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。</p></blockquote><h5 id="数字" tabindex="-1">数字 <a class="header-anchor" href="#数字" aria-hidden="true">#</a></h5><h6 id="整数类型" tabindex="-1">整数类型 <a class="header-anchor" href="#整数类型" aria-hidden="true">#</a></h6><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当初始化一个没有显式指定类型的变量时，编译器会自动推断为足以表示该值的最小类型。 如果不超过 Int 的表示范围，那么类型是 Int 。 如果超过了， 那么类型是 Long 。 如需显 式指定 Long 值，请给该值追加后缀 L 。 显式指定类型会触发编译器检测该值是否超出指 定类型的表示范围。</p></div><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#FF7B72;">val</span><span style="color:#C9D1D9;"> one </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">1</span><span style="color:#C9D1D9;"> </span><span style="color:#8B949E;">// Int</span></span>
<span class="line"><span style="color:#FF7B72;">val</span><span style="color:#C9D1D9;"> threeBillion </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">3000000000</span><span style="color:#C9D1D9;"> </span><span style="color:#8B949E;">// Long</span></span>
<span class="line"><span style="color:#FF7B72;">val</span><span style="color:#C9D1D9;"> oneLong </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">1L</span><span style="color:#C9D1D9;"> </span><span style="color:#8B949E;">// Long</span></span>
<span class="line"><span style="color:#FF7B72;">val</span><span style="color:#C9D1D9;"> oneByte</span><span style="color:#FF7B72;">:</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">Byte</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">1</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h6 id="浮点类型" tabindex="-1">浮点类型 <a class="header-anchor" href="#浮点类型" aria-hidden="true">#</a></h6><blockquote><p>对于实数，Kotlin 提供了浮点类型 Float 与 Double 类型，遵循 IEEE 754 标准。 Float 表达 IEEE 754 单精度，而 Double 表达双精度。 可以使用带小数部分的数字初始化 Double 与 Float 变量。 小数部分与整数部分之间用句点（ . ）分隔 对于以小数初始化的变量，编译器会推断为 Double 类型：</p></blockquote><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#FF7B72;">val</span><span style="color:#C9D1D9;"> pi </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">3.14</span><span style="color:#C9D1D9;"> </span><span style="color:#8B949E;">// Double</span></span>
<span class="line"><span style="color:#8B949E;">// val one: Double = 1 // 错误：类型不匹配</span></span>
<span class="line"><span style="color:#FF7B72;">val</span><span style="color:#C9D1D9;"> oneDouble </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">1.0</span><span style="color:#C9D1D9;"> </span><span style="color:#8B949E;">// Double</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>::: kotlin val pi = 3.14 // Double // val one: Double = 1 // 错误：类型不匹配 val oneDouble = 1.0 // Double :::</p><p>如需将一个值显式指定为 <code>Float</code> 类型，请添加 f 或 F 后缀。 如果这样的值包含多于 6～7 位十进制数，那么会将其舍入： ::: kotlin val e = 2.7182818284 // Double val eFloat = 2.7182818284f // Float，实际值为 2.7182817 :::</p><p>与一些其他语言不同，Kotlin 中的数字没有隐式拓宽转换。 例如，具有 Double 参数的函数 只能对 <code>Double</code> 值调用，而不能对 <code>Float</code> 、 <code>Int</code> 或者其他数字值调用：</p><p>::: kotlin fun main() { fun printDouble(d: Double) { print(d) } val i = 1 val d = 1.0 val f = 1.0f printDouble(d) // printDouble(i) // 错误：类型不匹配 // printDouble(f) // 错误：类型不匹配 } :::</p><h5 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-hidden="true">#</a></h5><blockquote><p>字符串字面值可以包含模板表达式——一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（ $ ）开头，要么由一个的名称构成:</p></blockquote><p>::: kotlin fun main() { //sampleStart val i = 10 println(&quot;i = $i&quot;) // 输出“i = 10” //sampleEnd } ::: 要么是用花括号括起来的表达式: ::: kotlin fun main() { //sampleStart val s = &quot;abc&quot; println(&quot;$s.length is \${s.length}&quot;) // 输出 &quot;abc.length is 3&quot; //sampleEnd } :::</p><h3 id="流程控制" tabindex="-1">流程控制 <a class="header-anchor" href="#流程控制" aria-hidden="true">#</a></h3><h4 id="if表达式" tabindex="-1">if表达式 <a class="header-anchor" href="#if表达式" aria-hidden="true">#</a></h4><p>在 Kotlin 中， <code>if</code> 是一个表达式：它会返回一个值。 因此就不需要三元运算符<code>（ 条件 ? 然后: 否则 ）</code>，因为普通的 <code>if</code> 就能胜任这个角色。 ::: kotlin var max = a if (a &lt; b) max = b</p><p>// With else var max: Int if (a &gt; b) { max = a } else { max = b }</p><p>// 作为表达式 val max = if (a &gt; b) a else b ::: <code>if</code> 表达式的分支可以是代码块，这种情况最后的表达式作为该块的值： ::: kotlin val max = if (a &gt; b) { print(&quot;Choose a&quot;) a } else { print(&quot;Choose b&quot;) b } :::</p><h4 id="when-表达式" tabindex="-1">When 表达式 <a class="header-anchor" href="#when-表达式" aria-hidden="true">#</a></h4><p>::: kotlin when (x) { 1 -&gt; print(&quot;x == 1&quot;) 2 -&gt; print(&quot;x == 2&quot;) else -&gt; { print(&quot;x is neither 1 nor 2&quot;) } } ::: <code>when</code>将它的参数与所有的分支条件顺序比较，直到某个分支满足条件。</p><p><code>when</code> 既可以作为表达式使用也可以作为语句使用。如果它被当做表达式， 第一个符合条件 的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。 类似于 <code>if</code> ， 每一个分支可以是一个代码块，它的值是块中最后的表达式的值。</p><p>如果其他分支都不满足条件将会求值 <code>else</code> 分支。 如果 <code>when</code> 作为一个表达式使用，那么必 须有 <code>else</code> 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了， 例如，对于 <code>枚举（ enum ）类</code>条目与<code>密封（ sealed ）类</code>子类型］。 ::: kotlin enum class Bit { ZERO, ONE } val numericValue = when (getRandomBit()) { Bit.ZERO -&gt; 0 Bit.ONE -&gt; 1 // &#39;else&#39; is not required because all cases are covered } :::</p><h3 id="包与导入" tabindex="-1">包与导入 <a class="header-anchor" href="#包与导入" aria-hidden="true">#</a></h3><h3 id="类与对象" tabindex="-1">类与对象 <a class="header-anchor" href="#类与对象" aria-hidden="true">#</a></h3><h4 id="伴生对象" tabindex="-1">伴生对象 <a class="header-anchor" href="#伴生对象" aria-hidden="true">#</a></h4><blockquote><p>kotlin通过引入“伴生对象”的概念来替代java里的静态变量及方法。</p></blockquote><p>“伴生对象”这个名词听上去很古怪，其实非常简单：在类的内容使用companion来标记一个对象。所有需要“静态化”的变量和方法都放在这个对象里。</p><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#FF7B72;">class</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">StaticTest</span><span style="color:#C9D1D9;"> {</span></span>
<span class="line"><span style="color:#C9D1D9;">    </span><span style="color:#FF7B72;">companion</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">object</span><span style="color:#C9D1D9;">{</span><span style="color:#8B949E;">//伴生对象是可以指定名字的，不过一般都省略掉。</span></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#FF7B72;">var</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">STATIC_VAR</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">=</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C9D1D9;">        </span><span style="color:#FF7B72;">fun</span><span style="color:#C9D1D9;"> </span><span style="color:#D2A8FF;">staticMethod</span><span style="color:#C9D1D9;">(str</span><span style="color:#FF7B72;">:</span><span style="color:#C9D1D9;"> </span><span style="color:#79C0FF;">String?</span><span style="color:#C9D1D9;">) {</span></span>
<span class="line"><span style="color:#C9D1D9;">            </span><span style="color:#79C0FF;">println</span><span style="color:#C9D1D9;">(str)</span></span>
<span class="line"><span style="color:#C9D1D9;">        }</span></span>
<span class="line"><span style="color:#C9D1D9;">    }</span></span>
<span class="line"><span style="color:#C9D1D9;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-hidden="true">#</a></h3><h4 id="基本使用" tabindex="-1">基本使用 <a class="header-anchor" href="#基本使用" aria-hidden="true">#</a></h4><h3 id="spring" tabindex="-1">Spring <a class="header-anchor" href="#spring" aria-hidden="true">#</a></h3><h4 id="自动注入" tabindex="-1">自动注入 <a class="header-anchor" href="#自动注入" aria-hidden="true">#</a></h4><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki github-dark has-highlighted-lines"><code><span class="line"><span style="color:#FF7B72;">class</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">TestClass</span><span style="color:#C9D1D9;"> (</span></span>
<span class="line"><span style="color:#C9D1D9;">  </span><span style="color:#8B949E;">// 自动注入的对象</span></span>
<span class="line highlighted"><span style="color:#C9D1D9;">  </span><span style="color:#FF7B72;">private</span><span style="color:#C9D1D9;"> </span><span style="color:#FF7B72;">val</span><span style="color:#C9D1D9;"> serviceX</span><span style="color:#FF7B72;">:</span><span style="color:#C9D1D9;"> </span><span style="color:#FFA657;">ServiceX</span></span>
<span class="line"><span style="color:#C9D1D9;">) { yourCode }</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div>`,44),p=[o];function r(t,i,c,d,h,u){return n(),a("div",null,p)}const y=s(e,[["render",r]]);export{D as __pageData,y as default};
